% TiMBL 5.1 API

\documentstyle[a4]{article}
%\usepackage{epsf}
%\usepackage{a4wide}
%\usepackage{palatino}
%\usepackage{fullname}

\parindent 0pt
\parskip 9pt

\newcommand{\chisq}{{$ \chi^2 $}}

\author{Ko van der Sloot\\ \ \\ Induction of Linguistic Knowledge\\
        Computational Linguistics\\ Tilburg University \\ \ \\
        P.O. Box 90153, NL-5000 LE, Tilburg, The Netherlands \\ URL:
        http://ilk.uvt.nl}

\title{{\huge TiMBL: Tilburg Memory-Based Learner} \\ \vspace*{0.5cm}
{\bf version 5.1} \\ \vspace*{0.5cm}{\huge API Reference Guide}\\
\vspace*{1cm} {\it ILK Technical Report -- ILK 05-01}}


\begin{document}

\maketitle

\clearpage
\section{Preface}

This is a brief description of the TimblAPI class and its main functions.
Not everything found in {\tt TimblAPI.h} is described. Some functions are
still "work in progress" and some others are artefacts to simplify the
implementation of the TiMBL main program\footnote{Timbl.cxx is
therefore {\em not} a good example of how to use the API.}.
To learn more about using the API, you should study programs like 
{\tt classify.cxx, tse.cxx} and of course the examples given in this
manual, which can be found in the {\tt demos} directory of this
distribution. 

As you can learn from these examples, all you need to get access to the
TimblAPI functions, is to include {\tt TimblAPI.h} in the program, and to
include {\tt libTimbl.a} in your linking path. 

{\bf Important note}: All described functions return a bool to indicate
succes or failure. To simplify the examples, we ignore these return
values. This is, of course, bad practice, to be avoided in
real life programming.

{\bf Warning}: Although the TiMBL internals perform some sanity
checking, it is quite possible to combine API functions such
that some undetermined state is reached, or even a conflict
arises. The effect of the {\tt SetOptions()} function, for instance,
might be quite surprising. If you have created your own program
with the API it might be wise to test against well-know data to see if
the results make sense.

\section{changes from 5.0 to 5.1}

The API is quite stable at the moment. Most TiMBL changes did not
affect the API. The only real API change is in the {\tt GetWeights()}
function. (see the section on Storing and retrieving intermediate
results).  A few options were added to Timbl, influencing the table in
Appendix A. We have also changed and enhanced the examples in Appendix
B.

\section{Starting our first experiment}

There is just one way to start a TiMBL experiment, and that is by
calling the TimblAPI constructor:

\begin{footnotesize}
\begin{verbatim}
  TimblAPI( const std::string& args, const std::string& name ="" );
\end{verbatim}
\end{footnotesize}

args is used as a "command line" and is parsed for all kind of options
which are used to create the right kind of experiment with the desired
settings for metric, weighting etc. If something is wrong with the
settings, {\em no}\/ object is created.

The most important option is {\tt -a}  to set the kind of algorithm,
e.g. {\tt -a IB1} to get an IB1 experiment or {\tt -a IGTREE} to get an IGTREE
experiment. A list of possible options is give in Appendix A.

The optional name can be useful if you have multiple experiments.
In case of warnings or errors, this name is appended to the message.

\paragraph{Example:}

\begin{footnotesize}
\begin{verbatim}
  TimblAPI *My_Experiment = new TimblAPI( "-a IGTREE +vDI+DB", 
                                          "test1" );
\end{verbatim}
\end{footnotesize}

{\tt My\_Experiment} is created as an IGTREE experiment with the name
"test1" and the verbosity is set to DI+DB, meaning that the output
will contain DIstance and DistriBution information.

Of course there is a counterpart to creation in the form of the 
{\tt \~{ }TimblAPI()} destructor, which is called when you delete an
experiment with:

\begin{footnotesize}
\begin{verbatim}
  delete My_Experiment;
\end{verbatim}
\end{footnotesize}

\section{Running our first experiment}

Assuming that we have appropriate datafiles, (such as {\tt
dimin.train} and {\tt dimin.test} in the TiMBL package) we can get
started quite easy with the functions {\tt Learn()} and {\tt Test()}.

\subsection{Training}
\begin{footnotesize}
\begin{verbatim}
  bool Learn( const std::string& f );
\end{verbatim}
\end{footnotesize}

This function takes a file with name 'f', and gathers information
like: number of features, number and frequency of feature values and
the same for class names. After that, these data are used to calculate
a lot of statistical information, which will be used for
testing. Finally, an InstanceBase is created, tuned to the current
algorithm.

\subsection{Testing}
\begin{footnotesize}
\begin{verbatim}
  bool Test( const std::string& in,
             const std::string& out,
             const std::string& perc = "" );
\end{verbatim}
\end{footnotesize}

Test a file given by 'in' and write results to 'out'. If 'perc' is not
empty, then a percentage score is written to file 'perc'.

\paragraph{Example:}
\begin{footnotesize}
\begin{verbatim}
  My_Experiment->Learn( "dimin.train" );  
  My_Experiment->Test( "dimin.test", "my_first_test" );  
\end{verbatim}
\end{footnotesize}

An InstanceBase will be created from dimin.train, then dimin.test is
tested against that InstanceBase and output is written to
my\_first\_test.

\subsection{special cases of Learing and Testing}
There are special cases where {\tt Learn()} behaves differently:

\begin{itemize}
\item When the algorithm is IB2, {\tt Learn()} will automatically take the
first $n$ lines of f (set with the {\tt -b n} option) to bootstrap itself,
and then the rest of f for IB2-learning. 

After Learning IB2, you can use {\tt Test()} as usual.

\item When the algorithm is CV, {\tt Learn()} is not defined, and all
  work is done in a special version of {\tt Test()}. 'f' is assumed to
  give the name of a file, which, on separate lines, gives the names
  of the files to be cross-validated.

See Appendix B for a complete CV example. (program {\tt api\_test3}).
\end{itemize}

\section{More about settings}

After an experiment is set up with the TimblAPI constructor, many
options can be changed "on the fly" with:

\begin{footnotesize}
\begin{verbatim}
  bool SetOptions( const std::string& opts );
\end{verbatim}
\end{footnotesize}

'opts' is interpreted as a list of options which are set, just like in
the TimblAPI constructor. When an error in the opts string is found,
{\tt SetOptions()} returns false. Whether any options are really set
or changed in that case is undefined. Note that a few options can only
be set {\em once}\/ when creating the experiment. Most notably the
algorithm. Any attempt to change these options will result in a
failure.  See Appendix A for all valid options and information about
the possibility to change them for a running experiment.

Note: {\tt SetOptions()} is "lazy"; changes are cached until the
moment they are really needed, so you can do several {\tt SetOptions()}
calls with even different values for the same option. Only the last
one seen will be used for running the experiment.

To see which options are in effect, you can use the calls {\tt ShowOptions()}
and {\tt ShowSettings()}.

\begin{footnotesize}
\begin{verbatim}
  bool ShowOptions( std::ostream& );
\end{verbatim}
\end{footnotesize}

Shows all options with their possible and current values.

\begin{footnotesize}
\begin{verbatim}
  bool ShowSettings( std::ostream& );
\end{verbatim}
\end{footnotesize}

Shows all options and their currect values.

\paragraph{Example:}

\begin{footnotesize}
\begin{verbatim}
  My_Experiment->SetOptions( "-w2 -m:M" );
  My_Experiment->SetOptions( "-w3 -v:DB" );
  My_Experiment->ShowSettings( cout )
\end{verbatim}
\end{footnotesize}

See Appendix B (program {\tt api\_test1}) for the output.

\section{Storing and retrieving intermediate results}

To speed up testing, or to manipulate what is happening internally,we
can store and retrieve several important parts of our experiment: The
InstanceBase, the FeatureWeights, and the ProbabilityArrays.

Saving is done with:

\begin{footnotesize}
\begin{verbatim}
  bool WriteInstanceBase( const std::string& f );
  bool SaveWeights( const std::string& f );
  bool WriteArrays( const std::string& f );
\end{verbatim}
\end{footnotesize}

Retrieve with their counterparts:

\begin{footnotesize}
\begin{verbatim}
  bool GetInstanceBase( const std::string& f );
  bool GetWeights( const std::string& f, Weighting w );
  bool GetArrays( const std::string& f );
\end{verbatim}
\end{footnotesize}

All use 'f' as a filename for storing/retrieving. {\tt GetWeights} needs
information to decide {\em which}\/ weighting to retrieve.
Weighting is defined as the enumerated type:

\begin{footnotesize}
\begin{verbatim}
  enum Weighting { UNKNOWN_W, UD, NW, GR, IG, X2, SV };
\end{verbatim}
\end{footnotesize}

Some notes:

\begin{enumerate}
\item The InstanceBase is stored in a internal format, with or without
hashing, depending on the {\tt -H} option. The format is described in the
TiMBL manual. Remember that it is a bad idea to edit this file in any way.
\item {\tt GetWeights()} can be used to override the weights that
{\tt Learn()} calculated. {\tt UNKNOWN\_W} should not be used.
\item The Probability arrays are described in the TiMBL manual. They can be
manipulated to tune MVDM testing.
\end{enumerate}

\section{Do it ourselves}

After an experiment is trained with {\tt Learn()}, we do not have to use
{\tt Test()} to do bulk-testing on a file.
We can wrap our own tests with the {\tt Classify} functions:

\begin{footnotesize}
\begin{verbatim}
  bool Classify( const std::string& Line, std::string& result );
  bool Classify( const std::string& Line, std::string& result, 
                 double& distance );
  bool Classify( const std::string& Line, std::string& result,
                 std::string& Distrib, double& distance );
\end{verbatim}
\end{footnotesize}

All versions will classify Line against the InstanceBase. Results are
stored in 'result' (the assigned class). 'distance' will contain the
calculated distance, and 'Distrib' the distribution at 'distance'
which is used to calculate 'result'.  Distrib will be a string like
``\{ NP 2, PP 6 \}''. It is up to you to parse and interpret this. (In
this case: There were 8 classes assigned at 'distance', 2 NP's and 6
PP's, giving a 'result' of ``PP'')

A main disadvantage compared to using {\tt Test()} is, that {\tt
  Test()} is optimized.  {\tt Classify()} has to test for sanity of
its input and also whether a {\tt SetOptions()} has been
performed. This slows down the process, of course.

A good example of the use of {\tt Classify()} is the {\tt
  classify.cxx} program in the TiMBL Distribution.

Depending on the Algorithm and Verbosity setting, it may be possible
to get some extra information on the choice that is made using:

\begin{footnotesize}
\begin{verbatim}
   const bool ShowBestNeighbors( std::ostream& os, bool distr ) const;
\end{verbatim}
\end{footnotesize}

Provided that the option {\tt +v n} or {\tt +v k} is set and we use an IB1 like
algorithm, output is produced similar to what we see in the TiMBL program.
When 'distr' is true, their distributions are also displayed.
Bear in mind: The {\tt +vn} option is expensive in time and memory and
does not work for IGTREE, TRIBL, and TRIBL-2.

Other functions that can be used to create your own special effects:

\begin{footnotesize}
\begin{verbatim}
  bool Increment( const std::string& Line ); 
  bool Decrement( const std::string& Line ); 
\end{verbatim}
\end{footnotesize}

These functions add or remove an Instance as described by Line to or
from the InstanceBase.
This can only be done for IB1-like experiments (IB1, IB2, CV and LOO).
This enforces a lot of statistical recalculations.

More sophisticated are:
\begin{footnotesize}
\begin{verbatim}
  bool Expand( const std::string& File  );
  bool Remove( const std::string& File );
\end{verbatim}
\end{footnotesize}

which use the contents of File to do a bulk of Increments or Decrements, and
recalculate afterwards.

\section{Getting more information out of Timbl}

There are a few convenience functions to get extra information on
TiMBL and its behaviour:

\begin{footnotesize}
\begin{verbatim}
  bool WriteNamesFile( const std::string& f );
\end{verbatim}
\end{footnotesize}

Create a file which resembles a C4.5 namesfile.

\begin{footnotesize}
\begin{verbatim}
  Algorithm Algo()
\end{verbatim}
\end{footnotesize}

Give the current algorithm as a type enum Algorithm.

Declaration of Algorithm:
\begin{footnotesize}
\begin{verbatim}
  enum Algorithm { UNKNOWN_ALG, IB1, IB2, IGTREE, 
                   TRIBL, TRIBL2, LOO, CV };
\end{verbatim}
\end{footnotesize}

This can be printed with the helper function: 

\begin{footnotesize}
\begin{verbatim}
  const std::string to_string( const Algorithm )
\end{verbatim}
\end{footnotesize}

\begin{footnotesize}
\begin{verbatim}
  Weighting CurrentWeighting()
\end{verbatim}
\end{footnotesize}

Gives the current weighting as a type enum Weighting.

Declaration of Weighting:
\begin{footnotesize}
\begin{verbatim}
  enum Weighting { UNKNOWN_W, UD, NW, GR, IG, X2, SV };
\end{verbatim}
\end{footnotesize}

This can be printed with the helper function: 

\begin{footnotesize}
\begin{verbatim}
  const std::string to_string( const Weighting )
\end{verbatim}
\end{footnotesize}


\begin{footnotesize}
\begin{verbatim}
  Weighting CurrentWeightings( std::vector<double>& v )
\end{verbatim}
\end{footnotesize}


Returns the current weighting as a type enum Weighting and also a
vector v with all the current values of this weighting.

\begin{footnotesize}
\begin{verbatim}
  std::string& ExpName()
\end{verbatim}
\end{footnotesize}


Return the value of 'name' given at the construction of the experiment


\begin{footnotesize}
\begin{verbatim}
  static std::string VersionInfo( bool full = false )
\end{verbatim}
\end{footnotesize}


return a string containing the Version number, the Revision and the
Revision string of the current API implementation. If full is true,
also information about the date and time of compilation is included.

\section{Using TiMBL as a Server}

\begin{footnotesize}
\begin{verbatim}
  bool StartServer( const int port, const int max_c );
\end{verbatim}
\end{footnotesize}

Start a TimblServer on 'port' with maximally 'max\_c' concurrent
connections to it. Starting a server makes sense only after the
experiment is trained.

\clearpage
\section{Appendix A}

Here we give a summmary of the options that can be set using the
{\tt Setoptions} API call. For detailed information about these options
you should refer to the TiMBL Manual.

\begin{tabular}{|r|r|l|}
\hline
\multicolumn{3}{|c|}{Options that only can be set {\bf once}}\\
\hline
option & value & description \\
\hline
-a &    & algorithm \\
   & 0 or IB1   & IB1     (default)\\
   & 1 or IG    & IGTREE \\
   & 2 or TRIBL & TRIBL \\
   & 3 or IB2   & IB2 \\
   & 4 or TRIBL2 & TRIBL2 \\
-b & integer  & number of lines used for bootstrapping (IB2 only)\\
-B & integer  & number of bins used for discretization of numeric feature\\
-F & format & Assume the specified inputformat. \\
 & &     (Compact, C4.5, ARFF, Columns, Binary, Sparse) \\
-l & integer & length of Features (Compact format only). \\
-M & integer & size of MaxBests Array \\
-N & integer & Number of features \\
-q & integer & TRIBL treshold at level n. \\
-T &     & internal order of the Tree : \\
   & DO  & none. \\
   & GRO & using GainRatio \\
   & IGO & using InformationGain \\
   & 1/V & using 1/\# of Vals \\
   & G/V & using GainRatio/\# of Vals \\
   & I/V & using InfoGain/\# of Vals \\
   & X2O & using X-square \\
   & X/V & using X-square/\# of Vals \\
   & SVO & using Shared Variance \\
   & S/V & using Shared Variance/\# of Vals \\
   & GxE & using GainRatio * SplitInfo \\
   & IxE & using InformationGain * SplitInfo \\
   & 1/S & using 1/SplitInfo \\
-w &  & weighting \\
   & 0 or nw & No Weighting. \\
   & 1 or gr & Weight using GainRatio. (default) \\
   & 2 or ig & Weight using InfoGain \\
   & 3 or x2 & Weight using Chi-square \\
   & 4 or sv & Weight using Shared Variance \\
   & name & use Weights from file 'name' \\
   & name:n & use Weight n from file 'name' \\
\hline
\end{tabular}

\newpage

\begin{tabular}{|l|r|l|}
\hline
\multicolumn{3}{|c|}{Other options}\ \\
\hline
option & value & description \\
\hline
-c & integer  & clipping rate for MVDM prestorage \\
-D & & don't store distributions. \\
-d &     & weight neighbors as function of their distance: \\
   &  Z  & all the same weight. (default) \\
   & ID  & Inverse Distance. \\
   & IL  & Inverse Linear \\
   & ED:a & Exponential Decay with factor a. (no whitespace!) \\
   & ED:a:b & Exponential Decay with factors a and b . (no whitespace!) \\
-e & n   &  estimate time until n patterns tested. \\
+H/-H & & write/don't write hashed trees (default +H) \\
-k & integer & k nearest neighbors (default n = 1). \\
-L & integer & MVDM treshold \\
-m &   &  metrics \\
   & D & Dot product. \\
   & O & weighted overlap. (default) \\
   & M & modified value difference. \\
   & N & numeric values. \\ 
   & I & Ignore named  values. \\
   & J & Jeffrey Divergence. \\
-p & integer & show progress every n lines. (default p = 100,000) \\
-R & integer & solve ties at random with seed n. \\
% -R & P n & solve ties probalistic with seed n \\
-s &  & expect exemplar weights in all input files, and use for training \\
   & 0 & expect but ignore exemplar weights from all files \\
   & 1 & ignore exemplar weights from the test file \\
-t &  leave\_one\_out & perform a leave one out test on the inputfile \\
-t &  cross\_validate & perform crossvalidation on the files specified
   in the inputfile \\
+v / -v &    & set or unset verbosity level, where level is \\
   & s  & work silently. \\
   & o  & show all options set. \\
   & f  & show Calculated Feature Weights. \\
   & p  & show MVD matrices. \\
   & e  & show exact matches. \\
   & as & show advanced statistics. \\
   & cm & show Confusion Matrix. \\
   & cs & show Class Statistics. \\
   & di & add distance to output file. \\
   & db & add distribution of best matched to output file \\
   & k  & add summary of nearest neigbors to output file   (sets -x) \\
   & n  & add all nearest neigbors to output file   (sets -x) \\
   &    &  You may combine levels using '+' e.g. +v p+db or -v o+di \\
-V & & Show VERSION. \\
+x/-x & & use/don't use the exact match shortcut.
 (IB only) (default:-x)\\
\hline
\end{tabular}

\clearpage
\section{Appendix B: Annotated example programs}

\subsection{example 1, api\_test1.cxx}
\begin{footnotesize}
\begin{verbatim}	
#include "TimblAPI.h"
int main(){
  TimblAPI My_Experiment( "-a IGTREE +vDI+DB+F", "test1" );
  My_Experiment.SetOptions( "-w2 -mM" );
  My_Experiment.SetOptions( "-w3 -vDB" );
  My_Experiment.ShowSettings( std::cout );
  My_Experiment.Learn( "dimin.train" );  
  My_Experiment.Test( "dimin.test", "my_first_test.out" );  
}
\end{verbatim}
\end{footnotesize}


Output:
\begin{footnotesize}
\begin{verbatim}
Current Experiment Settings :
FLENGTH              : 0
MAXBESTS             : 500
TRIBL_OFFSET         : 0
INPUTFORMAT          : Unknown
TREE_ORDER           : Unknown
ALL_WEIGHTS          : -
WEIGHTING            : x2                               [Note 1]
BIN_SIZE             : 20
IB2_OFFSET           : 0
DECAY                : Z
SEED                 : -1
DECAYPARAM_A         : 1.000000
DECAYPARAM_B         : 1.000000
EXEMPLAR_WEIGHTS     : -
IGNORE_EXEMPLAR_WEIGHTS : +
NO_EXEMPLAR_WEIGHTS_TEST : +
PROBALISTIC          : -
VERBOSITY            : F+DI                             [Note 2]
EXACT_MATCH          : -
DO_DOT_PRODUCT       : -
HASHED_TREE          : +
GLOBAL_METRIC        : M                                [Note 3]
METRICS              : 
MVD_LIMIT            : 1
NEIGHBORS            : 1
PROGRESS             : 100000
CLIP_FACTOR          : 10

Examine datafile 'dimin.train' gave the following results:
Number of Features: 12
InputFormat       : C4.5

-test1-Phase 1: Reading Datafile: dimin.train
-test1-Start:          0 @ Tue Dec  7 11:54:45 2004
-test1-Finished:    2999 @ Tue Dec  7 11:54:45 2004
-test1-Calculating Entropy         Tue Dec  7 11:54:45 2004
Lines of data     : 2999
DB Entropy        : 1.6178929
Number of Classes : 5

Feats	Vals	X-square	Variance	InfoGain	GainRatio
    1      3	128.41828	0.021410184	0.030971064	0.024891536
    2     50	364.75812	0.030406645	0.060860038	0.027552191
    3     19	212.29804	0.017697402	0.039562857	0.018676787
    4     37	449.83823	0.037499019	0.052541227	0.052620750
    5      3	288.87218	0.048161417	0.074523225	0.047699231
    6     61	415.64113	0.034648310	0.10604433	0.024471911
    7     20	501.33465	0.041791818	0.12348668	0.034953203
    8     69	367.66021	0.030648567	0.097198760	0.043983864
    9      2	169.36962	0.056475363	0.045752381	0.046816705
   10     64	914.61906	0.076243669	0.21388759	0.042844587
   11     18	2807.0418	0.23399815	0.66970458	0.18507018
   12     43	7160.3682	0.59689631	1.2780762	0.32537181

Feature Permutation based on Chi-Squared :
< 12, 11, 10, 7, 4, 6, 8, 2, 5, 3, 9, 1 >
-test1-Phase 2: Learning from Datafile: dimin.train
-test1-Start:          0 @ Tue Dec  7 11:54:45 2004
-test1-Finished:    2999 @ Tue Dec  7 11:54:46 2004

Size of InstanceBase = 29481 Nodes, (589620 bytes), 23.00 % compression

-test1-Start Pruning:            Tue Dec  7 11:54:46 2004
-test1-Finished Pruning:         Tue Dec  7 11:54:46 2004

Size of InstanceBase = 148 Nodes, (2960 bytes), 99.61 % compression

Warning:-test1-Metric set to Overlap for IGTree test.          [Note 1]
Examine datafile 'dimin.test' gave the following results:
Number of Features: 12
InputFormat       : C4.5


Starting to test, Testfile: dimin.test
Writing output in:          my_first_test.out
Algorithm     : IGTree

-test1-Tested:      1 @ Tue Dec  7 11:54:46 2004
-test1-Tested:      2 @ Tue Dec  7 11:54:46 2004
-test1-Tested:      3 @ Tue Dec  7 11:54:46 2004
-test1-Tested:      4 @ Tue Dec  7 11:54:46 2004
-test1-Tested:      5 @ Tue Dec  7 11:54:46 2004
-test1-Tested:      6 @ Tue Dec  7 11:54:46 2004
-test1-Tested:      7 @ Tue Dec  7 11:54:46 2004
-test1-Tested:      8 @ Tue Dec  7 11:54:46 2004
-test1-Tested:      9 @ Tue Dec  7 11:54:46 2004
-test1-Tested:     10 @ Tue Dec  7 11:54:46 2004
-test1-Tested:    100 @ Tue Dec  7 11:54:46 2004
-test1-Ready:     950 @ Tue Dec  7 11:54:46 2004
Seconds taken: 1 (950.00 p/s)
overall accuracy:        0.962105  (914/950)
\end{verbatim}
\end{footnotesize}


Notes:
\begin{enumerate}
\item The {\tt -w2} of the first {\tt SetOptions()} is overruled with {\tt -w3} from the
second {\tt SetOptions()}, resulting in a weighting of 3 or Chi-Square.
\item The first {\tt SetOptions()} sets the verbosity with {\tt +F+DI+DB}.
The second {\tt SetOptions()}, however, sets the verbosity with {\tt -vDB}, and the
resulting verbosity is therefore {\tt F+DI}.
\item Due to the second {\tt SetOptions()}, the default metric is set to
MVDM --- this is however not applicable to IGTREE. This raises a warning
later on, when we start to test and the API informs us that Overlap is
used instead.
\end{enumerate}

Result in my\_first\_test.out (first 20 lines):
\begin{footnotesize}
\begin{verbatim}
=,=,=,=,=,=,=,=,+,p,e,=,T,T        6619.8512628162
=,=,=,=,+,k,u,=,-,bl,u,m,E,P        2396.8557978603
+,m,I,=,-,d,A,G,-,d,},t,J,J        6619.8512628162
-,t,@,=,-,l,|,=,-,G,@,n,T,T        6619.8512628162
-,=,I,n,-,str,y,=,+,m,E,nt,J,J        6619.8512628162
=,=,=,=,=,=,=,=,+,br,L,t,J,J        6619.8512628162
=,=,=,=,+,zw,A,=,-,m,@,r,T,T        6619.8512628162
=,=,=,=,-,f,u,=,+,dr,a,l,T,T        6619.8512628162
=,=,=,=,=,=,=,=,+,l,e,w,T,T        13780.219414719
=,=,=,=,+,tr,K,N,-,k,a,rt,J,J        6619.8512628162
=,=,=,=,+,=,o,=,-,p,u,=,T,T        3812.8095095379
=,=,=,=,=,=,=,=,+,l,A,m,E,E        3812.8095095379
=,=,=,=,=,=,=,=,+,l,A,p,J,J        6619.8512628162
=,=,=,=,=,=,=,=,+,sx,E,lm,P,P        6619.8512628162
+,l,a,=,-,d,@,=,-,k,A,st,J,J        6619.8512628162
-,s,i,=,-,f,E,r,-,st,O,k,J,J        6619.8512628162
=,=,=,=,=,=,=,=,+,sp,a,n,T,T        6619.8512628162
=,=,=,=,=,=,=,=,+,st,o,t,J,J        6619.8512628162
=,=,=,=,+,sp,a,r,-,b,u,k,J,J        6619.8512628162
+,h,I,N,-,k,@,l,-,bl,O,k,J,J        6619.8512628162
\end{verbatim}
\end{footnotesize}

\subsection{example 2, {\tt api\_test2.cxx}}
This demonstrates IB2 learning.

Our example program:

\begin{footnotesize}
\begin{verbatim}
#include "TimblAPI.h"
int main(){
  TimblAPI *My_Experiment = new TimblAPI( "-a IB2 +vF+DI+DB" , 
                                          "test2" );
  My_Experiment->SetOptions( "-b100" );
  My_Experiment->ShowSettings( std::cout );
  My_Experiment->Learn( "dimin.train" );  
  My_Experiment->Test( "dimin.test", "my_second_test.out" );
  delete My_Experiment;
  exit(1);
}
\end{verbatim}
\end{footnotesize}


We create an experiment for the IB2 algorithm, with the {\tt -b} option set
to 100, so the first 100 lines of {\tt dimin.train} will be used to
bootstrap the learning, as we can see from the output:

\begin{footnotesize}
\begin{verbatim}
Current Experiment Settings :
FLENGTH              : 0
MAXBESTS             : 500
TRIBL_OFFSET         : 0
INPUTFORMAT          : Unknown
TREE_ORDER           : G/V
ALL_WEIGHTS          : -
WEIGHTING            : gr
BIN_SIZE             : 20
IB2_OFFSET           : 100
DECAY                : Z
SEED                 : -1
DECAYPARAM_A         : 1.000000
DECAYPARAM_B         : 1.000000
EXEMPLAR_WEIGHTS     : -
IGNORE_EXEMPLAR_WEIGHTS : +
NO_EXEMPLAR_WEIGHTS_TEST : +
PROBALISTIC          : -
VERBOSITY            : F+DI+DB
EXACT_MATCH          : -
DO_DOT_PRODUCT       : -
HASHED_TREE          : +
GLOBAL_METRIC        : O
METRICS              : 
MVD_LIMIT            : 1
NEIGHBORS            : 1
PROGRESS             : 100000
CLIP_FACTOR          : 10

Examine datafile 'dimin.train' gave the following results:
Number of Features: 12
InputFormat       : C4.5

-test2-Phase 1: Reading Datafile: dimin.train
-test2-Start:          0 @ Tue Dec  7 11:47:10 2004
-test2-Finished:     100 @ Tue Dec  7 11:47:10 2004
-test2-Calculating Entropy         Tue Dec  7 11:47:10 2004
Lines of data     : 100
DB Entropy        : 1.7148291
Number of Classes : 5

Feats	Vals	InfoGain	GainRatio
    1      3	0.059969698	0.041607175
    2     16	0.31505423	0.14385015
    3     13	0.28508033	0.11717175
    4     12	0.29549424	0.20791549
    5      3	0.081665925	0.053303154
    6     25	0.52671728	0.13537479
    7     15	0.35043203	0.10312857
    8     21	0.33767640	0.14930809
    9      2	0.031832973	0.033768474
   10     29	0.70753849	0.15973455
   11     14	0.90357639	0.25337382
   12     22	1.3841139	0.34375881

Feature Permutation based on GainRatio/Values :
< 11, 5, 4, 9, 12, 1, 3, 2, 8, 7, 10, 6 >
-test2-Phase 2: Learning from Datafile: dimin.train
-test2-Start:          0 @ Tue Dec  7 11:47:10 2004
-test2-Finished:     100 @ Tue Dec  7 11:47:10 2004

Size of InstanceBase = 991 Nodes, (19820 bytes), 23.77 % compression

-test2-Phase 2: Appending from Datafile: dimin.train (starting at line 101)
-test2-Start:        101 @ Tue Dec  7 11:47:10 2004
-test2-Finished:    2999 @ Tue Dec  7 11:47:10 2004
added 243 new entries                                      [Note 1]

Size of InstanceBase = 2816 Nodes, (56320 bytes), 32.52 % compression

DB Entropy        : 2.06102214
Number of Classes : 5

Feats	Vals	InfoGain	GainRatio
    1      3	0.04554767	0.03383515
    2     26	0.21712128	0.09871036
    3     15	0.16940288	0.07558872
    4     16	0.13396509	0.11878590
    5      3	0.07680154	0.04866030
    6     32	0.30386439	0.07867154
    7     18	0.26978935	0.08149390
    8     30	0.18332100	0.09408395
    9      2	0.07760376	0.07785647
   10     42	0.45192062	0.09432288
   11     16	0.63364433	0.17494936
   12     40	1.34781701	0.31742342

Examine datafile 'dimin.test' gave the following results:
Number of Features: 12
InputFormat       : C4.5


Starting to test, Testfile: dimin.test
Writing output in:          my_second_test.out
Algorithm     : IB2
Global metric : Overlap
Deviant Feature Metrics:(none)
Weighting     : GainRatio
Feature 1	 : 0.033835145963271
Feature 2	 : 0.098710361953118
Feature 3	 : 0.075588723963477
Feature 4	 : 0.118785903920912
Feature 5	 : 0.048660299116492
Feature 6	 : 0.078671538452017
Feature 7	 : 0.081493895194308
Feature 8	 : 0.094083953380450
Feature 9	 : 0.077856473802927
Feature 10	 : 0.094322883333513
Feature 11	 : 0.174949363233078
Feature 12	 : 0.317423417741858

-test2-Tested:      1 @ Tue Dec  7 11:47:10 2004
-test2-Tested:      2 @ Tue Dec  7 11:47:10 2004
-test2-Tested:      3 @ Tue Dec  7 11:47:10 2004
-test2-Tested:      4 @ Tue Dec  7 11:47:10 2004
-test2-Tested:      5 @ Tue Dec  7 11:47:10 2004
-test2-Tested:      6 @ Tue Dec  7 11:47:10 2004
-test2-Tested:      7 @ Tue Dec  7 11:47:10 2004
-test2-Tested:      8 @ Tue Dec  7 11:47:10 2004
-test2-Tested:      9 @ Tue Dec  7 11:47:10 2004
-test2-Tested:     10 @ Tue Dec  7 11:47:10 2004
-test2-Tested:    100 @ Tue Dec  7 11:47:10 2004
-test2-Ready:     950 @ Tue Dec  7 11:47:10 2004
Seconds taken: 1 (950.00 p/s)
overall accuracy:        0.934737  (888/950), of which 15 exact matches 
                                                         [Note 2]
There were 58 ties of which 47 (81.03%) were correctly resolved
\end{verbatim}
\end{footnotesize}


Notes:
\begin{enumerate}
\item As we see here, 243 entries from the inputfile had a mismatch,
and were therefore entered in the Instancebase.
\item We see that IB2 scores 93.47 \%, compared to 96.21 \% for IGTREE
in our first example. 
For this data, IB2 is not a good algorithm. However, it saves a
lot of space, and is faster than IB1. However, IGtree is both faster and
better. Had we used IB1, the score would have been 96.84 \%.
\end{enumerate}

\subsection{example 3, {\tt api\_test3.cxx}}
This demonstrates Cross Validation:

Lets try the following program:

\begin{footnotesize}
\begin{verbatim}
#include "TimblAPI.h"

int main(){
  TimblAPI *My_Experiment = new TimblAPI( "-t cross_validate" );
  My_Experiment->Test( "cross_val.test" );  
  delete My_Experiment;
  exit(0);
}
\end{verbatim}
\end{footnotesize}


We create an experiment, which defaults to IB1 and because of the
special option ``-t cross\_validate'' will start a CrossValidation
experiment.\\
Learn() is not possible now. We must use a special form of Test().

``cross\_val.test'' is a file with the following content:
\begin{footnotesize}
\begin{verbatim}
small_1.train
small_2.train
small_3.train
small_4.train
small_5.train
\end{verbatim}
\end{footnotesize}


All these files contain an equal part of a bigger dataset, and
My\_Experiment will run a CrossValidation test between these files.
Note that output filenames are generated and that you cannot influence
that.

The output of this program is:

\begin{footnotesize}
\begin{verbatim}
Starting Cross validation test on files:
small_1.train
small_2.train
small_3.train
small_4.train
small_5.train
Examine datafile 'small_1.train' gave the following results:
Number of Features: 8
InputFormat       : C4.5


Starting to test, Testfile: small_1.train
Writing output in:          small_1.train.cv
Algorithm     : CV
Global metric : Overlap
Deviant Feature Metrics:(none)
Weighting     : GainRatio

Tested:      1 @ Tue Dec  7 11:59:31 2004
Tested:      2 @ Tue Dec  7 11:59:31 2004
Tested:      3 @ Tue Dec  7 11:59:31 2004
Tested:      4 @ Tue Dec  7 11:59:31 2004
Tested:      5 @ Tue Dec  7 11:59:31 2004
Tested:      6 @ Tue Dec  7 11:59:31 2004
Tested:      7 @ Tue Dec  7 11:59:31 2004
Tested:      8 @ Tue Dec  7 11:59:31 2004
Tested:      9 @ Tue Dec  7 11:59:31 2004
Tested:     10 @ Tue Dec  7 11:59:31 2004
Ready:      10 @ Tue Dec  7 11:59:31 2004
Seconds taken: 1 (10.00 p/s)
overall accuracy:        0.800000  (8/10)
Examine datafile 'small_2.train' gave the following results:
Number of Features: 8
InputFormat       : C4.5


Starting to test, Testfile: small_2.train
Writing output in:          small_2.train.cv
Algorithm     : CV
Global metric : Overlap
Deviant Feature Metrics:(none)
Weighting     : GainRatio

Tested:      1 @ Tue Dec  7 11:59:31 2004
Tested:      2 @ Tue Dec  7 11:59:31 2004
Tested:      3 @ Tue Dec  7 11:59:31 2004
Tested:      4 @ Tue Dec  7 11:59:31 2004
Tested:      5 @ Tue Dec  7 11:59:31 2004
Tested:      6 @ Tue Dec  7 11:59:31 2004
Tested:      7 @ Tue Dec  7 11:59:31 2004
Tested:      8 @ Tue Dec  7 11:59:31 2004
Tested:      9 @ Tue Dec  7 11:59:31 2004
Tested:     10 @ Tue Dec  7 11:59:31 2004
Ready:      10 @ Tue Dec  7 11:59:31 2004
Seconds taken: 1 (10.00 p/s)
overall accuracy:        0.800000  (8/10)
Examine datafile 'small_3.train' gave the following results:
Number of Features: 8
InputFormat       : C4.5


Starting to test, Testfile: small_3.train
Writing output in:          small_3.train.cv
Algorithm     : CV
Global metric : Overlap
Deviant Feature Metrics:(none)
Weighting     : GainRatio

Tested:      1 @ Tue Dec  7 11:59:31 2004
Tested:      2 @ Tue Dec  7 11:59:31 2004
Tested:      3 @ Tue Dec  7 11:59:31 2004
Tested:      4 @ Tue Dec  7 11:59:31 2004
Tested:      5 @ Tue Dec  7 11:59:31 2004
Tested:      6 @ Tue Dec  7 11:59:31 2004
Tested:      7 @ Tue Dec  7 11:59:31 2004
Tested:      8 @ Tue Dec  7 11:59:31 2004
Tested:      9 @ Tue Dec  7 11:59:31 2004
Tested:     10 @ Tue Dec  7 11:59:31 2004
Ready:      10 @ Tue Dec  7 11:59:31 2004
Seconds taken: 1 (10.00 p/s)
overall accuracy:        0.900000  (9/10)
Examine datafile 'small_4.train' gave the following results:
Number of Features: 8
InputFormat       : C4.5


Starting to test, Testfile: small_4.train
Writing output in:          small_4.train.cv
Algorithm     : CV
Global metric : Overlap
Deviant Feature Metrics:(none)
Weighting     : GainRatio

Tested:      1 @ Tue Dec  7 11:59:31 2004
Tested:      2 @ Tue Dec  7 11:59:31 2004
Tested:      3 @ Tue Dec  7 11:59:31 2004
Tested:      4 @ Tue Dec  7 11:59:31 2004
Tested:      5 @ Tue Dec  7 11:59:31 2004
Tested:      6 @ Tue Dec  7 11:59:31 2004
Tested:      7 @ Tue Dec  7 11:59:31 2004
Tested:      8 @ Tue Dec  7 11:59:31 2004
Tested:      9 @ Tue Dec  7 11:59:31 2004
Tested:     10 @ Tue Dec  7 11:59:31 2004
Ready:      10 @ Tue Dec  7 11:59:31 2004
Seconds taken: 1 (10.00 p/s)
overall accuracy:        0.800000  (8/10)
Examine datafile 'small_5.train' gave the following results:
Number of Features: 8
InputFormat       : C4.5


Starting to test, Testfile: small_5.train
Writing output in:          small_5.train.cv
Algorithm     : CV
Global metric : Overlap
Deviant Feature Metrics:(none)
Weighting     : GainRatio

Tested:      1 @ Tue Dec  7 11:59:31 2004
Tested:      2 @ Tue Dec  7 11:59:31 2004
Tested:      3 @ Tue Dec  7 11:59:31 2004
Tested:      4 @ Tue Dec  7 11:59:31 2004
Tested:      5 @ Tue Dec  7 11:59:31 2004
Tested:      6 @ Tue Dec  7 11:59:31 2004
Tested:      7 @ Tue Dec  7 11:59:31 2004
Tested:      8 @ Tue Dec  7 11:59:31 2004
Ready:       8 @ Tue Dec  7 11:59:31 2004
Seconds taken: 1 (8.00 p/s)
overall accuracy:        1.000000  (8/8)
\end{verbatim}
\end{footnotesize}


What has happened here?

\begin{enumerate}
\item TiMBL trained itself with inputfiles small\_2.train through
small\_5.train. (in fact using the {\tt Expand()} API call.
\item Then TiMBL tested small\_1.train against the InstanceBase.
\item next, small\_2.train is removed from the database (API call {\tt
Remove()} ) and small\_1.train is added.
\item Then small\_2.train is tested against the InstanceBase
\item and so forth with small\_3.train ...
\end{enumerate}

\subsection{example 4, {\tt api\_test4.cxx}}

This program demonstrates adding and deleting of the instancebase.  It
should also prove that weights are (re)calculated correctly each
time. (which also explains why this is a time-consuming thing to do)
After running this program, wg.1 should be equal to wg.5 and wg.2 eq
to wg.4. Important to note is also, that while we do not use a
weighting of X2 or SV here, only the ``simple'' weights are calculated
and stored.

First the program: 

\begin{footnotesize}
\begin{verbatim}
#include <iostream>
#include "TimblAPI.h"

int main(){
  TimblAPI *My_Experiment = new TimblAPI( "-a IB1 +vDI+DB +mM" , 
                                          "test4" );
  My_Experiment->ShowSettings( std::cout );
  My_Experiment->Learn( "dimin.train" );  
  My_Experiment->Test( "dimin.test", "inc1.out" );
  My_Experiment->SaveWeights( "wg.1" );  
  My_Experiment->WriteArrays( "arr.1" );  
  My_Experiment->Increment( "=,=,=,=,+,k,e,=,-,r,@,l,T" );  
  My_Experiment->Test( "dimin.test", "inc2.out" );
  My_Experiment->SaveWeights( "wg.2" );  
  My_Experiment->WriteArrays( "arr.2" );  
  My_Experiment->Increment( "+,zw,A,rt,-,k,O,p,-,n,O,n,E" );  
  My_Experiment->Test( "dimin.test", "inc3.out" );
  My_Experiment->SaveWeights( "wg.3" );  
  My_Experiment->WriteArrays( "arr.3" );  
  My_Experiment->Decrement( "+,zw,A,rt,-,k,O,p,-,n,O,n,E" );  
  My_Experiment->Test( "dimin.test", "inc4.out" );
  My_Experiment->SaveWeights( "wg.4" );  
  My_Experiment->WriteArrays( "arr.4" );  
  My_Experiment->Decrement( "=,=,=,=,+,k,e,=,-,r,@,l,T" );  
  My_Experiment->Test( "dimin.test", "inc5.out" );
  My_Experiment->SaveWeights( "wg.5" );  
  My_Experiment->WriteArrays( "arr.5" );  
  delete My_Experiment;
  exit(1);
}
\end{verbatim}
\end{footnotesize}


This produces the following output:
\begin{footnotesize}
\begin{verbatim}
Current Experiment Settings :
FLENGTH              : 0
MAXBESTS             : 500
TRIBL_OFFSET         : 0
INPUTFORMAT          : Unknown
TREE_ORDER           : G/V
ALL_WEIGHTS          : -
WEIGHTING            : gr
BIN_SIZE             : 20
IB2_OFFSET           : 0
DECAY                : Z
SEED                 : -1
DECAYPARAM_A         : 1.000000
DECAYPARAM_B         : 1.000000
EXEMPLAR_WEIGHTS     : -
IGNORE_EXEMPLAR_WEIGHTS : +
NO_EXEMPLAR_WEIGHTS_TEST : +
PROBALISTIC          : -
VERBOSITY            : DI+DB
EXACT_MATCH          : -
DO_DOT_PRODUCT       : -
HASHED_TREE          : +
GLOBAL_METRIC        : M
METRICS              : 
MVD_LIMIT            : 1
NEIGHBORS            : 1
PROGRESS             : 100000
CLIP_FACTOR          : 10

Examine datafile 'dimin.train' gave the following results:
Number of Features: 12
InputFormat       : C4.5

-test4-Phase 1: Reading Datafile: dimin.train
-test4-Start:          0 @ Mon Nov 29 15:38:23 2004
-test4-Finished:    2999 @ Mon Nov 29 15:38:23 2004
-test4-Calculating Entropy         Mon Nov 29 15:38:23 2004
Feature Permutation based on GainRatio/Values :
< 9, 5, 11, 1, 12, 7, 4, 3, 10, 8, 2, 6 >
-test4-Phase 2: Learning from Datafile: dimin.train
-test4-Start:          0 @ Mon Nov 29 15:38:23 2004
-test4-Finished:    2999 @ Mon Nov 29 15:38:23 2004

Size of InstanceBase = 19231 Nodes, (384620 bytes), 49.77 % compression

Examine datafile 'dimin.test' gave the following results:
Number of Features: 12
InputFormat       : C4.5


Starting to test, Testfile: dimin.test
Writing output in:          inc1.out
Algorithm     : IB1
Global metric : Value Difference, Prestored matrix
Deviant Feature Metrics:(none)
Size of value-matrix[1] = 96 Bytes 
Size of value-matrix[2] = 704 Bytes 
Size of value-matrix[3] = 704 Bytes 
Size of value-matrix[4] = 96 Bytes 
Size of value-matrix[5] = 96 Bytes 
Size of value-matrix[6] = 1496 Bytes 
Size of value-matrix[7] = 1496 Bytes 
Size of value-matrix[8] = 336 Bytes 
Size of value-matrix[9] = 56 Bytes 
Size of value-matrix[10] = 2376 Bytes 
Size of value-matrix[11] = 1344 Bytes 
Size of value-matrix[12] = 936 Bytes 
Total Size of value-matrices 9736 Bytes 

Weighting     : GainRatio

-test4-Tested:      1 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      2 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      3 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      4 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      5 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      6 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      7 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      8 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      9 @ Mon Nov 29 15:38:23 2004
-test4-Tested:     10 @ Mon Nov 29 15:38:23 2004
-test4-Tested:    100 @ Mon Nov 29 15:38:23 2004
-test4-Ready:     950 @ Mon Nov 29 15:38:23 2004
Seconds taken: 1 (950.00 p/s)
overall accuracy:        0.963158  (915/950), of which 62 exact matches 

There were 6 ties of which 5 (83.33%) were correctly resolved
-test4-Saving Weights in wg.1
-test4-Saving Probability Arrays in arr.1
Examine datafile 'dimin.test' gave the following results:
Number of Features: 12
InputFormat       : C4.5


Starting to test, Testfile: dimin.test
Writing output in:          inc2.out
Algorithm     : IB1
Global metric : Value Difference, Prestored matrix
Deviant Feature Metrics:(none)
Size of value-matrix[1] = 96 Bytes 
Size of value-matrix[2] = 704 Bytes 
Size of value-matrix[3] = 704 Bytes 
Size of value-matrix[4] = 96 Bytes 
Size of value-matrix[5] = 96 Bytes 
Size of value-matrix[6] = 1496 Bytes 
Size of value-matrix[7] = 1496 Bytes 
Size of value-matrix[8] = 336 Bytes 
Size of value-matrix[9] = 56 Bytes 
Size of value-matrix[10] = 2376 Bytes 
Size of value-matrix[11] = 1344 Bytes 
Size of value-matrix[12] = 936 Bytes 
Total Size of value-matrices 9736 Bytes 

Weighting     : GainRatio

-test4-Tested:      1 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      2 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      3 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      4 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      5 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      6 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      7 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      8 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      9 @ Mon Nov 29 15:38:23 2004
-test4-Tested:     10 @ Mon Nov 29 15:38:23 2004
-test4-Tested:    100 @ Mon Nov 29 15:38:23 2004
-test4-Ready:     950 @ Mon Nov 29 15:38:23 2004
Seconds taken: 1 (950.00 p/s)
overall accuracy:        0.963158  (915/950), of which 62 exact matches 

There were 6 ties of which 5 (83.33%) were correctly resolved
-test4-Saving Weights in wg.2
-test4-Saving Probability Arrays in arr.2
Examine datafile 'dimin.test' gave the following results:
Number of Features: 12
InputFormat       : C4.5


Starting to test, Testfile: dimin.test
Writing output in:          inc3.out
Algorithm     : IB1
Global metric : Value Difference, Prestored matrix
Deviant Feature Metrics:(none)
Size of value-matrix[1] = 96 Bytes 
Size of value-matrix[2] = 704 Bytes 
Size of value-matrix[3] = 704 Bytes 
Size of value-matrix[4] = 96 Bytes 
Size of value-matrix[5] = 96 Bytes 
Size of value-matrix[6] = 1496 Bytes 
Size of value-matrix[7] = 1496 Bytes 
Size of value-matrix[8] = 336 Bytes 
Size of value-matrix[9] = 56 Bytes 
Size of value-matrix[10] = 2376 Bytes 
Size of value-matrix[11] = 1344 Bytes 
Size of value-matrix[12] = 936 Bytes 
Total Size of value-matrices 9736 Bytes 

Weighting     : GainRatio

-test4-Tested:      1 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      2 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      3 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      4 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      5 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      6 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      7 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      8 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      9 @ Mon Nov 29 15:38:23 2004
-test4-Tested:     10 @ Mon Nov 29 15:38:23 2004
-test4-Tested:    100 @ Mon Nov 29 15:38:23 2004
-test4-Ready:     950 @ Mon Nov 29 15:38:23 2004
Seconds taken: 1 (950.00 p/s)
overall accuracy:        0.963158  (915/950), of which 62 exact matches 

There were 6 ties of which 5 (83.33%) were correctly resolved
-test4-Saving Weights in wg.3
-test4-Saving Probability Arrays in arr.3
Examine datafile 'dimin.test' gave the following results:
Number of Features: 12
InputFormat       : C4.5


Starting to test, Testfile: dimin.test
Writing output in:          inc4.out
Algorithm     : IB1
Global metric : Value Difference, Prestored matrix
Deviant Feature Metrics:(none)
Size of value-matrix[1] = 96 Bytes 
Size of value-matrix[2] = 704 Bytes 
Size of value-matrix[3] = 704 Bytes 
Size of value-matrix[4] = 96 Bytes 
Size of value-matrix[5] = 96 Bytes 
Size of value-matrix[6] = 1496 Bytes 
Size of value-matrix[7] = 1496 Bytes 
Size of value-matrix[8] = 336 Bytes 
Size of value-matrix[9] = 56 Bytes 
Size of value-matrix[10] = 2376 Bytes 
Size of value-matrix[11] = 1344 Bytes 
Size of value-matrix[12] = 936 Bytes 
Total Size of value-matrices 9736 Bytes 

Weighting     : GainRatio

-test4-Tested:      1 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      2 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      3 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      4 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      5 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      6 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      7 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      8 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      9 @ Mon Nov 29 15:38:23 2004
-test4-Tested:     10 @ Mon Nov 29 15:38:23 2004
-test4-Tested:    100 @ Mon Nov 29 15:38:23 2004
-test4-Ready:     950 @ Mon Nov 29 15:38:23 2004
Seconds taken: 1 (950.00 p/s)
overall accuracy:        0.963158  (915/950), of which 62 exact matches 

There were 6 ties of which 5 (83.33%) were correctly resolved
-test4-Saving Weights in wg.4
-test4-Saving Probability Arrays in arr.4
Examine datafile 'dimin.test' gave the following results:
Number of Features: 12
InputFormat       : C4.5


Starting to test, Testfile: dimin.test
Writing output in:          inc5.out
Algorithm     : IB1
Global metric : Value Difference, Prestored matrix
Deviant Feature Metrics:(none)
Size of value-matrix[1] = 96 Bytes 
Size of value-matrix[2] = 704 Bytes 
Size of value-matrix[3] = 704 Bytes 
Size of value-matrix[4] = 96 Bytes 
Size of value-matrix[5] = 96 Bytes 
Size of value-matrix[6] = 1496 Bytes 
Size of value-matrix[7] = 1496 Bytes 
Size of value-matrix[8] = 336 Bytes 
Size of value-matrix[9] = 56 Bytes 
Size of value-matrix[10] = 2376 Bytes 
Size of value-matrix[11] = 1344 Bytes 
Size of value-matrix[12] = 936 Bytes 
Total Size of value-matrices 9736 Bytes 

Weighting     : GainRatio

-test4-Tested:      1 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      2 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      3 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      4 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      5 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      6 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      7 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      8 @ Mon Nov 29 15:38:23 2004
-test4-Tested:      9 @ Mon Nov 29 15:38:23 2004
-test4-Tested:     10 @ Mon Nov 29 15:38:23 2004
-test4-Tested:    100 @ Mon Nov 29 15:38:23 2004
-test4-Ready:     950 @ Mon Nov 29 15:38:24 2004
Seconds taken: 1 (950.00 p/s)
overall accuracy:        0.963158  (915/950), of which 62 exact matches 

There were 6 ties of which 5 (83.33%) were correctly resolved
-test4-Saving Weights in wg.5
-test4-Saving Probability Arrays in arr.5
\end{verbatim}
\end{footnotesize}


\end{document}
